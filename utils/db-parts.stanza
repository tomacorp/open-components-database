#use-added-syntax(esir)
defpackage ocdb/db-parts :
  import core
  import collections
  import json
  import math
  import esir
  import esir/utils
  import esir/gen
  import jitpcb/bom-query
  import ocdb/tests/default-harness

  import ocdb/land-patterns
  import ocdb/generator-utils
  import ocdb/symbols
  import ocdb/design-vars


defn make-cap (json:JObject):
  inside pcb-component :
    val manufacturer-string = get?(json, "manufacturer")
    match(manufacturer-string:String) :  manufacturer = manufacturer-string
    val mpn-string = get?(json, "mpn")
    match(mpn-string:String) : mpn = mpn-string
    val description-string = get?(json, "description")
    match(description-string:String) : description = description-string
    reference-prefix = "C"
    val type-string = get?(json, "type") as String
    val package-generator = get?(json["package"] as JObject, "generator") as String
    val package-args = get?(json["package"] as JObject, "arg") as String|False
    val c-x = get?(json["dimensions"] as JObject, "x") as Double
    val c-y = get?(json["dimensions"] as JObject, "y") as Double
    if type-string == "ceramic" or type-string == "film" :
      port p : pin[{1 2}]
      symbol = {capacitor-sym(false)}(p[1] => p[1], p[2] => p[2])
      switch(package-generator):
        "ipc-two-pin-package" :
            match(package-args:String) : package = {ipc-two-pin-package(package-args)}(p[1] => p[1], p[2] => p[2])
        "dummy-package" :
          package = {dummy-package(2, [c-x c-y])}(p[1] => p[1], p[2] => p[2])
    else:
      pin a
      pin c
      symbol = {capacitor-sym(true)}(a => p[1], c => p[2])
      switch(package-generator):
        "ipc-two-pin-package" :
          match(package-args:String) : package = {ipc-two-pin-package(package-args)}(a => p[1], c => p[2])
        "dummy-package" :
          package = {dummy-package(2, [c-x c-y])}(a => p[1], c => p[2])

    val capacitance-json = get?(json, "capacitance") as Double|False
    val rated-voltage-json = get?(json, "rated-voltage") as Double|False
    val temperature-coefficient-json = get?(json, "temperature-coefficient")
    val tolerance-json = get?(json, "tolerance")
    val anode-json = get?(json, "anode")
    val electrolyte-json = get?(json, "electrolyte")
    val esr-json = get?(json, "esr") as Double|False
    val rated-current-rms-json = get?(json, "rated-current-rms") as Double|False
    val rated-temperature-json = [get?(json["rated-temperature"] as JObject, "min") as Double,
                                  get?(json["rated-temperature"] as JObject, "max") as Double]

    properties :
      capacitor => true
      match(capacitance-json:Double) : capacitance => capacitance-json
      match(rated-voltage-json:Double) : rated-voltage => rated-voltage-json
      match(temperature-coefficient-json:String) : temperature-coefficient => temperature-coefficient-json
      match(tolerance-json:Double) : tolerance => tolerance-json
      match(rated-temperature-json:Tuple<Double>) : rated-temperature => rated-temperature-json
      match(type-string:String) : type => type-string
      match(anode-json:String) : anode => anode-json
      match(electrolyte-json:String) : electrolyte => electrolyte-json
      match(esr-json:Double) : esr => esr-json
      match(rated-current-rms-json:Double) : rated-current-rms => rated-current-rms-json


defn capacitor (properties:Tuple<KeyValue>) :
    ;Query the database with the given properties
    val query_properties = to-tuple $ cat(["category" => "capacitor", "_optimize_for" => to-tuple(OPTIMIZE-FOR)], properties)
    val reply = dbquery(query_properties)

    ;Declare a new lazily-generated component
    unique pcb-component mycomponent :
      try :
        make-cap(json(reply))
      catch (e:HTTPError) :
        print(e)
    ;Return component
    mycomponent

deftest works :
    val _props = ["min-capacitance" => 1.0e-3, "max-capacitance" => 2.0e-3]

    ;val cap = capacitor(_props)

    val query_properties = to-tuple $ cat(["category" => "capacitor", "_optimize_for" => to-tuple(OPTIMIZE-FOR)], _props)

    val reply = dbquery(query_properties)
    println(json(reply))